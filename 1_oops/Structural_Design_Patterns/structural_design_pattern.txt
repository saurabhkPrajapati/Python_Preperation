Structural Design Patterns:
    Structural design patterns are design patterns in software development that focus on organizing classes and objects into larger, cohesive structures,
    while keeping the system flexible, maintainable, reusable, and efficient.
    Simplify complex relationships between objects.
    Facilitate code reuse and reduce tight coupling.

______________________________________________________________________________________________________________________________________________________________________

Common Patterns:

Adapter – Allow incompatible interfaces to work together (wrapper).

Bridge – Separate abstraction from implementation so they can vary independently.

Composite – Compose objects into tree structures to represent part-whole hierarchies.

Decorator – Add new functionality to an object dynamically.

Facade – Provide a simplified interface to a complex subsystem.

Flyweight – Use sharing to support large numbers of similar objects efficiently.

Proxy – Provide a surrogate or placeholder for another object to control access to it.
______________________________________________________________________________________________________________________________________________________________________

Adapter Pattern:
    The Adapter Pattern is a structural design pattern that allows incompatible interfaces to work together by creating
    a "wrapper" (adapter) that translates one interface to another.
    This is especially useful when you have existing code or libraries that need to be integrated but do not match the interface expected by your system

Scenario:
    Using a European Socket with an American Plug
    Suppose you're in Europe with an American plug device, and European sockets don't directly support it.
    The Adapter Pattern solves this by creating a "socket adapter" that converts the European socket to work with the American plug.

Implementation in Python
    Target Interface: EuropeanSocket represents the European standard socket.
    Adaptee: AmericanPlugDevice represents the incompatible American plug.
    Adapter: SocketAdapter makes AmericanPlugDevice compatible with EuropeanSocket.

______________________________________________________________________________________________________________________________________________________________________

Decorator Pattern:
    The Decorator Design Pattern is a structural pattern used to dynamically add behavior or responsibilities to an object at runtime without modifying its structure.
    This is achieved by wrapping the object with one or more decorators, each providing additional functionality.

Key Concepts
    Component Interface: Defines the common interface for objects and their decorators.
    Concrete Component: The main object to which functionalities are added dynamically.
    Decorator: A class that implements the component interface and wraps the concrete component, adding extra behavior.
______________________________________________________________________________________________________________________________________________________________________

Proxy Pattern:
    The Proxy Design Pattern is a structural design pattern that provides a surrogate or placeholder for another object to control access to it.
    A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.
    A proxy can add functionality such as lazy initialization, logging, access control, or caching to the original object without modifying its structure.


Benefits of Proxy Pattern:
    Access Control: Protect sensitive resources.
    Lazy Initialization: Defer expensive object creation until required.
    Logging: Track operations for debugging or auditing.
    Encapsulation: Abstract away the complexity of underlying objects.

Key Use Cases:
    Remote Proxy: Represents an object in a different address space (e.g., remote servers).
    Virtual Proxy: Creates expensive objects on demand.
    Protection Proxy: Controls access to sensitive objects based on permissions.
    Caching Proxy: Stores results of expensive operations for reuse.
______________________________________________________________________________________________________________________________________________________________________

______________________________________________________________________________________________________________________________________________________________________

______________________________________________________________________________________________________________________________________________________________________

______________________________________________________________________________________________________________________________________________________________________
