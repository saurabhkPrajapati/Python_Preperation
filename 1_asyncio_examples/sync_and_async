A routine is a general term for any block of code that can be executed independently of the rest of the program.
This could include functions, procedures, methods, and even entire programs.

***Subroutines:
    Subroutines are sequences of instructions that perform a specific task. It may return one or more values, but does not have to.

***Function:
    A function would return the returning value/control to the code or calling function.

***Procedure:
    A procedure, on the other hand, would return the control, but would not return any value to the calling function or the code.

_______________________________________________________________________________________________________________________________________________________________________________


****process***
An instance of a program that is currently running. It includes the program's code, data (variables, memory space), and its current execution state (registers, program counter).
Larger and more encompassing. A single process can contain multiple threads that work together to achieve a complex task.

***Thread***

A unit of execution within a process. A thread shares the same memory space and resources of the process it belongs to, but it has its own execution stack (keeping track of function calls and local variables).
Smaller and more lightweight compared to a process. Threads are ideal for handling concurrent tasks within a single program.

***ProcessPoolExecutor***

ProcessPoolExecutor is non-blocking. It asynchronously executes tasks in separate processes, allowing for concurrent execution of multiple tasks.
This means that while one task is being executed in a process, other tasks can be submitted and executed concurrently in separate processes.
The main program flow continues without waiting for the tasks to complete, making it non-blocking

ProcessPoolExecutor does not use threads. Instead, it uses processes.
Each task submitted to a ProcessPoolExecutor is executed in a separate process, allowing for true parallelism by utilizing multiple CPU cores.
This approach avoids the limitations of the Global Interpreter Lock (GIL) in Python, which prevents true parallel execution of threads due to its interpreter-level lock.


________________________________________________________________________________________________________________________________________________________________________________


***Core Concepts in Asyncio***:

Event Loop:
    The event loop is the heart of asynchronous programming in Python.
    It continuously monitors events (like completion of I/O operations, timers, etc.) and schedules coroutines to run based on these events.
Coroutines:
    Coroutines are asynchronous functions that can be suspended and resumed later.
    This allows the event loop to switch between coroutines while waiting for I/O operations. Coroutines are defined using the async keyword.
    ****A subroutine can be executed, starting at one point and finishing at another point and cannot be suspended
Asynchronous Tasks:
    Asynchronous tasks are created from coroutines using asyncio.create_task(). The event loop manages these tasks, ensuring they run efficiently.



